{"ast":null,"code":"import window from 'global/window';\nvar regexs = {\n  // to determine mime types\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n  // to determine if a codec is audio or video\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n  text: /^(stpp.ttml.im1t)/,\n  // mux.js support regex\n  muxerVideo: /^(avc0?1)/,\n  muxerAudio: /^(mp4a)/,\n  // match nothing as muxer does not support text right now.\n  // there cannot never be a character before the start of a string\n  // so this matches nothing.\n  muxerText: /a^/\n};\nvar mediaTypes = ['video', 'audio', 'text'];\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string} codec\n *        Codec string to translate\n * @return {string}\n *         The translated codec string\n */\n\nexport var translateLegacyCodec = function translateLegacyCodec(codec) {\n  if (!codec) {\n    return codec;\n  }\n\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\n  });\n};\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string[]} codecs\n *        An array of codec strings to translate\n * @return {string[]}\n *         The translated array of codec strings\n */\n\nexport var translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(translateLegacyCodec);\n};\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param {string} codecString\n *        The codec string\n * @return {string}\n *         The codec string with old apple-style codecs replaced\n *\n * @private\n */\n\nexport var mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n/**\n * @typedef {Object} ParsedCodecInfo\n * @property {number} codecCount\n *           Number of codecs parsed\n * @property {string} [videoCodec]\n *           Parsed video codec (if found)\n * @property {string} [videoObjectTypeIndicator]\n *           Video object type indicator (if found)\n * @property {string|null} audioProfile\n *           Audio profile\n */\n\n/**\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\n * object type indicator, and the audio profile.\n *\n * @param {string} [codecString]\n *        The codec string to parse\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nexport var parseCodecs = function parseCodecs(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  var codecs = codecString.split(',');\n  var result = [];\n  codecs.forEach(function (codec) {\n    codec = codec.trim();\n    var codecType;\n    mediaTypes.forEach(function (name) {\n      var match = regexs[name].exec(codec.toLowerCase());\n\n      if (!match || match.length <= 1) {\n        return;\n      }\n\n      codecType = name; // maintain codec case\n\n      var type = codec.substring(0, match[1].length);\n      var details = codec.replace(type, '');\n      result.push({\n        type: type,\n        details: details,\n        mediaType: name\n      });\n    });\n\n    if (!codecType) {\n      result.push({\n        type: codec,\n        details: '',\n        mediaType: 'unknown'\n      });\n    }\n  });\n  return result;\n};\n/**\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n * a default alternate audio playlist for the provided audio group.\n *\n * @param {Object} master\n *        The master playlist\n * @param {string} audioGroupId\n *        ID of the audio group for which to find the default codec info\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nexport var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\n    }\n  }\n\n  return null;\n};\nexport var isVideoCodec = function isVideoCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.video.test(codec.trim().toLowerCase());\n};\nexport var isAudioCodec = function isAudioCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.audio.test(codec.trim().toLowerCase());\n};\nexport var isTextCodec = function isTextCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.text.test(codec.trim().toLowerCase());\n};\nexport var getMimeForCodec = function getMimeForCodec(codecString) {\n  if (!codecString || typeof codecString !== 'string') {\n    return;\n  }\n\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\n    return translateLegacyCodec(c.trim());\n  }); // default to video type\n\n  var type = 'video'; // only change to audio type if the only codec we have is\n  // audio\n\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n    type = 'audio';\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n    // text uses application/<container> for now\n    type = 'application';\n  } // default the container to mp4\n\n\n  var container = 'mp4'; // every codec must be able to go into the container\n  // for that container to be the correct one\n\n  if (codecs.every(function (c) {\n    return regexs.mp4.test(c);\n  })) {\n    container = 'mp4';\n  } else if (codecs.every(function (c) {\n    return regexs.webm.test(c);\n  })) {\n    container = 'webm';\n  } else if (codecs.every(function (c) {\n    return regexs.ogg.test(c);\n  })) {\n    container = 'ogg';\n  }\n\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n};\nexport var browserSupportsCodec = function browserSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n};\nexport var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return codecString.toLowerCase().split(',').every(function (codec) {\n    codec = codec.trim(); // any match is supported.\n\n    for (var i = 0; i < upperMediaTypes.length; i++) {\n      var type = upperMediaTypes[i];\n\n      if (regexs[\"muxer\" + type].test(codec)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\nexport var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\nexport var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/codecs.js"],"names":["window","regexs","mp4","webm","ogg","video","audio","text","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","replace","orig","profile","avcLevel","profileHex","Number","toString","slice","avcLevelHex","translateLegacyCodecs","codecs","map","mapLegacyAvcCodecs","codecString","match","parseCodecs","split","result","forEach","trim","codecType","name","exec","toLowerCase","length","type","substring","details","push","mediaType","codecsFromDefault","master","audioGroupId","mediaGroups","AUDIO","audioGroup","audioType","default","playlists","attributes","CODECS","isVideoCodec","test","isAudioCodec","isTextCodec","getMimeForCodec","c","container","every","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","i","DEFAULT_AUDIO_CODEC","DEFAULT_VIDEO_CODEC"],"mappings":"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","sourcesContent":["import window from 'global/window';\nvar regexs = {\n  // to determine mime types\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n  // to determine if a codec is audio or video\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n  text: /^(stpp.ttml.im1t)/,\n  // mux.js support regex\n  muxerVideo: /^(avc0?1)/,\n  muxerAudio: /^(mp4a)/,\n  // match nothing as muxer does not support text right now.\n  // there cannot never be a character before the start of a string\n  // so this matches nothing.\n  muxerText: /a^/\n};\nvar mediaTypes = ['video', 'audio', 'text'];\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string} codec\n *        Codec string to translate\n * @return {string}\n *         The translated codec string\n */\n\nexport var translateLegacyCodec = function translateLegacyCodec(codec) {\n  if (!codec) {\n    return codec;\n  }\n\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\n  });\n};\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string[]} codecs\n *        An array of codec strings to translate\n * @return {string[]}\n *         The translated array of codec strings\n */\n\nexport var translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(translateLegacyCodec);\n};\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param {string} codecString\n *        The codec string\n * @return {string}\n *         The codec string with old apple-style codecs replaced\n *\n * @private\n */\n\nexport var mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n/**\n * @typedef {Object} ParsedCodecInfo\n * @property {number} codecCount\n *           Number of codecs parsed\n * @property {string} [videoCodec]\n *           Parsed video codec (if found)\n * @property {string} [videoObjectTypeIndicator]\n *           Video object type indicator (if found)\n * @property {string|null} audioProfile\n *           Audio profile\n */\n\n/**\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\n * object type indicator, and the audio profile.\n *\n * @param {string} [codecString]\n *        The codec string to parse\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nexport var parseCodecs = function parseCodecs(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  var codecs = codecString.split(',');\n  var result = [];\n  codecs.forEach(function (codec) {\n    codec = codec.trim();\n    var codecType;\n    mediaTypes.forEach(function (name) {\n      var match = regexs[name].exec(codec.toLowerCase());\n\n      if (!match || match.length <= 1) {\n        return;\n      }\n\n      codecType = name; // maintain codec case\n\n      var type = codec.substring(0, match[1].length);\n      var details = codec.replace(type, '');\n      result.push({\n        type: type,\n        details: details,\n        mediaType: name\n      });\n    });\n\n    if (!codecType) {\n      result.push({\n        type: codec,\n        details: '',\n        mediaType: 'unknown'\n      });\n    }\n  });\n  return result;\n};\n/**\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n * a default alternate audio playlist for the provided audio group.\n *\n * @param {Object} master\n *        The master playlist\n * @param {string} audioGroupId\n *        ID of the audio group for which to find the default codec info\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\nexport var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\n    }\n  }\n\n  return null;\n};\nexport var isVideoCodec = function isVideoCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.video.test(codec.trim().toLowerCase());\n};\nexport var isAudioCodec = function isAudioCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.audio.test(codec.trim().toLowerCase());\n};\nexport var isTextCodec = function isTextCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.text.test(codec.trim().toLowerCase());\n};\nexport var getMimeForCodec = function getMimeForCodec(codecString) {\n  if (!codecString || typeof codecString !== 'string') {\n    return;\n  }\n\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\n    return translateLegacyCodec(c.trim());\n  }); // default to video type\n\n  var type = 'video'; // only change to audio type if the only codec we have is\n  // audio\n\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n    type = 'audio';\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n    // text uses application/<container> for now\n    type = 'application';\n  } // default the container to mp4\n\n\n  var container = 'mp4'; // every codec must be able to go into the container\n  // for that container to be the correct one\n\n  if (codecs.every(function (c) {\n    return regexs.mp4.test(c);\n  })) {\n    container = 'mp4';\n  } else if (codecs.every(function (c) {\n    return regexs.webm.test(c);\n  })) {\n    container = 'webm';\n  } else if (codecs.every(function (c) {\n    return regexs.ogg.test(c);\n  })) {\n    container = 'ogg';\n  }\n\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n};\nexport var browserSupportsCodec = function browserSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n};\nexport var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return codecString.toLowerCase().split(',').every(function (codec) {\n    codec = codec.trim(); // any match is supported.\n\n    for (var i = 0; i < upperMediaTypes.length; i++) {\n      var type = upperMediaTypes[i];\n\n      if (regexs[\"muxer\" + type].test(codec)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\nexport var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\nexport var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';"]},"metadata":{},"sourceType":"module"}