{"ast":null,"code":"/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/stream.js"],"names":["Stream","listeners","_proto","prototype","on","type","listener","push","off","index","indexOf","slice","splice","trigger","callbacks","arguments","length","i","call","args","Array","_length","_i","apply","dispose","pipe","destination","data","default"],"mappings":"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","sourcesContent":["/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };"]},"metadata":{},"sourceType":"module"}