{"ast":null,"code":"import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/ebml-helpers.js"],"names":["toUint8","bytesToNumber","bytesMatch","bytesToString","numberToBytes","padStart","getAvcCodec","getHvcCodec","getAv1Codec","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","Track","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","VideoTrack","AudioTrack","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getLength","byte","len","i","length","getvint","bytes","offset","removeLength","signed","valueBytes","subarray","Array","prototype","slice","call","value","normalizePath","path","match","map","p","normalizePaths","paths","isArray","getInfinityDataSize","id","innerid","dataHeader","findEbml","results","dataStart","dataEnd","data","push","concat","totalLength","decodeBlock","block","type","timestampScale","clusterTimestamp","duration","dv","DataView","buffer","byteOffset","byteLength","trackNumber","timestamp","getInt16","flags","ptsdts","parsed","keyframe","invisible","lacing","discardable","frames","pts","dts","numberOfFrames","frameSizes","sizeOfFrame","_i","size","_size","_i2","vint","forEach","parseVp9Private","params","val","profile","level","bitDepth","chromaSubsampling","parseTracks","decodedTracks","tracks","track","trackType","decodedTrack","rawCodec","codecPrivate","number","defaultDuration","default","rawData","codec","test","toString","_parseVp9Private","matrixCoefficients","videoFullRangeFlag","transferCharacteristics","colourPrimaries","sort","a","b","parseData","allBlocks","segment","clusters","cluster","ci","simpleBlocks","blockGroups","blocks","bi","decoded"],"mappings":"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","sourcesContent":["import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};"]},"metadata":{},"sourceType":"module"}