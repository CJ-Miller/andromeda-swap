{"ast":null,"code":"import { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/nal-helpers.js"],"names":["bytesMatch","toUint8","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","bytes","positions","i","length","subarray","push","newLength","newData","Uint8Array","sourceIndex","shift","findNal","dataType","types","nalLimit","Infinity","concat","nalStart","nalsFound","nalOffset","nalType","indexOf","findH264Nal","type","findH265Nal"],"mappings":"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","sourcesContent":["import { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};"]},"metadata":{},"sourceType":"module"}