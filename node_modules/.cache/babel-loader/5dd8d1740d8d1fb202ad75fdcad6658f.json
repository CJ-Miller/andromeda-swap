{"ast":null,"code":"import { padStart, toHexString, toBinaryString } from './byte-helpers.js'; // https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#AV1\n\nexport var getAv1Codec = function getAv1Codec(bytes) {\n  var codec = '';\n  var profile = bytes[1] >>> 3;\n  var level = bytes[1] & 0x1F;\n  var tier = bytes[2] >>> 7;\n  var highBitDepth = (bytes[2] & 0x40) >> 6;\n  var twelveBit = (bytes[2] & 0x20) >> 5;\n  var monochrome = (bytes[2] & 0x10) >> 4;\n  var chromaSubsamplingX = (bytes[2] & 0x08) >> 3;\n  var chromaSubsamplingY = (bytes[2] & 0x04) >> 2;\n  var chromaSamplePosition = bytes[2] & 0x03;\n  codec += profile + \".\" + padStart(level, 2, '0');\n\n  if (tier === 0) {\n    codec += 'M';\n  } else if (tier === 1) {\n    codec += 'H';\n  }\n\n  var bitDepth;\n\n  if (profile === 2 && highBitDepth) {\n    bitDepth = twelveBit ? 12 : 10;\n  } else {\n    bitDepth = highBitDepth ? 10 : 8;\n  }\n\n  codec += \".\" + padStart(bitDepth, 2, '0'); // TODO: can we parse color range??\n\n  codec += \".\" + monochrome;\n  codec += \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition;\n  return codec;\n};\nexport var getAvcCodec = function getAvcCodec(bytes) {\n  var profileId = toHexString(bytes[1]);\n  var constraintFlags = toHexString(bytes[2] & 0xFC);\n  var levelId = toHexString(bytes[3]);\n  return \"\" + profileId + constraintFlags + levelId;\n};\nexport var getHvcCodec = function getHvcCodec(bytes) {\n  var codec = '';\n  var profileSpace = bytes[1] >> 6;\n  var profileId = bytes[1] & 0x1F;\n  var tierFlag = (bytes[1] & 0x20) >> 5;\n  var profileCompat = bytes.subarray(2, 6);\n  var constraintIds = bytes.subarray(6, 12);\n  var levelId = bytes[12];\n\n  if (profileSpace === 1) {\n    codec += 'A';\n  } else if (profileSpace === 2) {\n    codec += 'B';\n  } else if (profileSpace === 3) {\n    codec += 'C';\n  }\n\n  codec += profileId + \".\"; // ffmpeg does this in big endian\n\n  var profileCompatVal = parseInt(toBinaryString(profileCompat).split('').reverse().join(''), 2); // apple does this in little endian...\n\n  if (profileCompatVal > 255) {\n    profileCompatVal = parseInt(toBinaryString(profileCompat), 2);\n  }\n\n  codec += profileCompatVal.toString(16) + \".\";\n\n  if (tierFlag === 0) {\n    codec += 'L';\n  } else {\n    codec += 'H';\n  }\n\n  codec += levelId;\n  var constraints = '';\n\n  for (var i = 0; i < constraintIds.length; i++) {\n    var v = constraintIds[i];\n\n    if (v) {\n      if (constraints) {\n        constraints += '.';\n      }\n\n      constraints += v.toString(16);\n    }\n  }\n\n  if (constraints) {\n    codec += \".\" + constraints;\n  }\n\n  return codec;\n};","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/codec-helpers.js"],"names":["padStart","toHexString","toBinaryString","getAv1Codec","bytes","codec","profile","level","tier","highBitDepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","bitDepth","getAvcCodec","profileId","constraintFlags","levelId","getHvcCodec","profileSpace","tierFlag","profileCompat","subarray","constraintIds","profileCompatVal","parseInt","split","reverse","join","toString","constraints","i","length","v"],"mappings":"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","sourcesContent":["import { padStart, toHexString, toBinaryString } from './byte-helpers.js'; // https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#AV1\n\nexport var getAv1Codec = function getAv1Codec(bytes) {\n  var codec = '';\n  var profile = bytes[1] >>> 3;\n  var level = bytes[1] & 0x1F;\n  var tier = bytes[2] >>> 7;\n  var highBitDepth = (bytes[2] & 0x40) >> 6;\n  var twelveBit = (bytes[2] & 0x20) >> 5;\n  var monochrome = (bytes[2] & 0x10) >> 4;\n  var chromaSubsamplingX = (bytes[2] & 0x08) >> 3;\n  var chromaSubsamplingY = (bytes[2] & 0x04) >> 2;\n  var chromaSamplePosition = bytes[2] & 0x03;\n  codec += profile + \".\" + padStart(level, 2, '0');\n\n  if (tier === 0) {\n    codec += 'M';\n  } else if (tier === 1) {\n    codec += 'H';\n  }\n\n  var bitDepth;\n\n  if (profile === 2 && highBitDepth) {\n    bitDepth = twelveBit ? 12 : 10;\n  } else {\n    bitDepth = highBitDepth ? 10 : 8;\n  }\n\n  codec += \".\" + padStart(bitDepth, 2, '0'); // TODO: can we parse color range??\n\n  codec += \".\" + monochrome;\n  codec += \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition;\n  return codec;\n};\nexport var getAvcCodec = function getAvcCodec(bytes) {\n  var profileId = toHexString(bytes[1]);\n  var constraintFlags = toHexString(bytes[2] & 0xFC);\n  var levelId = toHexString(bytes[3]);\n  return \"\" + profileId + constraintFlags + levelId;\n};\nexport var getHvcCodec = function getHvcCodec(bytes) {\n  var codec = '';\n  var profileSpace = bytes[1] >> 6;\n  var profileId = bytes[1] & 0x1F;\n  var tierFlag = (bytes[1] & 0x20) >> 5;\n  var profileCompat = bytes.subarray(2, 6);\n  var constraintIds = bytes.subarray(6, 12);\n  var levelId = bytes[12];\n\n  if (profileSpace === 1) {\n    codec += 'A';\n  } else if (profileSpace === 2) {\n    codec += 'B';\n  } else if (profileSpace === 3) {\n    codec += 'C';\n  }\n\n  codec += profileId + \".\"; // ffmpeg does this in big endian\n\n  var profileCompatVal = parseInt(toBinaryString(profileCompat).split('').reverse().join(''), 2); // apple does this in little endian...\n\n  if (profileCompatVal > 255) {\n    profileCompatVal = parseInt(toBinaryString(profileCompat), 2);\n  }\n\n  codec += profileCompatVal.toString(16) + \".\";\n\n  if (tierFlag === 0) {\n    codec += 'L';\n  } else {\n    codec += 'H';\n  }\n\n  codec += levelId;\n  var constraints = '';\n\n  for (var i = 0; i < constraintIds.length; i++) {\n    var v = constraintIds[i];\n\n    if (v) {\n      if (constraints) {\n        constraints += '.';\n      }\n\n      constraints += v.toString(16);\n    }\n  }\n\n  if (constraints) {\n    codec += \".\" + constraints;\n  }\n\n  return codec;\n};"]},"metadata":{},"sourceType":"module"}