{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { namehash } from 'ethers/lib/utils';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from '../state/multicall/hooks';\nimport isZero from '../utils/isZero';\nimport { useENSRegistrarContract, useENSResolverContract } from './useContract';\n/**\n * Does a lookup for an ENS name to find its contenthash.\n */\n\nexport default function useENSContentHash(ensName) {\n  _s();\n\n  var _resolverAddressResul, _contenthash$result$, _contenthash$result;\n\n  const ensNodeArgument = useMemo(() => {\n    if (!ensName) return [undefined];\n\n    try {\n      return ensName ? [namehash(ensName)] : [undefined];\n    } catch (error) {\n      return [undefined];\n    }\n  }, [ensName]);\n  const registrarContract = useENSRegistrarContract(false);\n  const resolverAddressResult = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument);\n  const resolverAddress = (_resolverAddressResul = resolverAddressResult.result) === null || _resolverAddressResul === void 0 ? void 0 : _resolverAddressResul[0];\n  const resolverContract = useENSResolverContract(resolverAddress && isZero(resolverAddress) ? undefined : resolverAddress, false);\n  const contenthash = useSingleCallResult(resolverContract, 'contenthash', ensNodeArgument);\n  return {\n    contenthash: (_contenthash$result$ = (_contenthash$result = contenthash.result) === null || _contenthash$result === void 0 ? void 0 : _contenthash$result[0]) !== null && _contenthash$result$ !== void 0 ? _contenthash$result$ : null,\n    loading: resolverAddressResult.loading || contenthash.loading\n  };\n}\n\n_s(useENSContentHash, \"20z3dSuAG28I46Mtx7GCgNFB188=\", false, function () {\n  return [useENSRegistrarContract, useSingleCallResult, useENSResolverContract, useSingleCallResult];\n});","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/src/hooks/useENSContentHash.ts"],"names":["namehash","useMemo","useSingleCallResult","isZero","useENSRegistrarContract","useENSResolverContract","useENSContentHash","ensName","ensNodeArgument","undefined","error","registrarContract","resolverAddressResult","resolverAddress","result","resolverContract","contenthash","loading"],"mappings":";;AAAA,SAASA,QAAT,QAAyB,kBAAzB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,mBAAT,QAAoC,0BAApC;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,SAASC,uBAAT,EAAkCC,sBAAlC,QAAgE,eAAhE;AAEA;AACA;AACA;;AACA,eAAe,SAASC,iBAAT,CAA2BC,OAA3B,EAAsG;AAAA;;AAAA;;AACnH,QAAMC,eAAe,GAAGP,OAAO,CAAC,MAAM;AACpC,QAAI,CAACM,OAAL,EAAc,OAAO,CAACE,SAAD,CAAP;;AACd,QAAI;AACF,aAAOF,OAAO,GAAG,CAACP,QAAQ,CAACO,OAAD,CAAT,CAAH,GAAyB,CAACE,SAAD,CAAvC;AACD,KAFD,CAEE,OAAOC,KAAP,EAAc;AACd,aAAO,CAACD,SAAD,CAAP;AACD;AACF,GAP8B,EAO5B,CAACF,OAAD,CAP4B,CAA/B;AAQA,QAAMI,iBAAiB,GAAGP,uBAAuB,CAAC,KAAD,CAAjD;AACA,QAAMQ,qBAAqB,GAAGV,mBAAmB,CAACS,iBAAD,EAAoB,UAApB,EAAgCH,eAAhC,CAAjD;AACA,QAAMK,eAAe,4BAAGD,qBAAqB,CAACE,MAAzB,0DAAG,sBAA+B,CAA/B,CAAxB;AACA,QAAMC,gBAAgB,GAAGV,sBAAsB,CAC7CQ,eAAe,IAAIV,MAAM,CAACU,eAAD,CAAzB,GAA6CJ,SAA7C,GAAyDI,eADZ,EAE7C,KAF6C,CAA/C;AAIA,QAAMG,WAAW,GAAGd,mBAAmB,CAACa,gBAAD,EAAmB,aAAnB,EAAkCP,eAAlC,CAAvC;AAEA,SAAO;AACLQ,IAAAA,WAAW,iDAAEA,WAAW,CAACF,MAAd,wDAAE,oBAAqB,CAArB,CAAF,uEAA6B,IADnC;AAELG,IAAAA,OAAO,EAAEL,qBAAqB,CAACK,OAAtB,IAAiCD,WAAW,CAACC;AAFjD,GAAP;AAID;;GAtBuBX,iB;UASIF,uB,EACIF,mB,EAELG,sB,EAILH,mB","sourcesContent":["import { namehash } from 'ethers/lib/utils'\nimport { useMemo } from 'react'\nimport { useSingleCallResult } from '../state/multicall/hooks'\nimport isZero from '../utils/isZero'\nimport { useENSRegistrarContract, useENSResolverContract } from './useContract'\n\n/**\n * Does a lookup for an ENS name to find its contenthash.\n */\nexport default function useENSContentHash(ensName?: string | null): { loading: boolean; contenthash: string | null } {\n  const ensNodeArgument = useMemo(() => {\n    if (!ensName) return [undefined]\n    try {\n      return ensName ? [namehash(ensName)] : [undefined]\n    } catch (error) {\n      return [undefined]\n    }\n  }, [ensName])\n  const registrarContract = useENSRegistrarContract(false)\n  const resolverAddressResult = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument)\n  const resolverAddress = resolverAddressResult.result?.[0]\n  const resolverContract = useENSResolverContract(\n    resolverAddress && isZero(resolverAddress) ? undefined : resolverAddress,\n    false\n  )\n  const contenthash = useSingleCallResult(resolverContract, 'contenthash', ensNodeArgument)\n\n  return {\n    contenthash: contenthash.result?.[0] ?? null,\n    loading: resolverAddressResult.loading || contenthash.loading\n  }\n}\n"]},"metadata":{},"sourceType":"module"}