{"ast":null,"code":"// import React, { useCallback, useState } from 'react'\n// import { BigNumber } from '@ethersproject/bignumber'\n// import { TransactionResponse } from '@ethersproject/providers'\n// import { Currency, currencyEquals, ETHER, TokenAmount, WETH } from '@pancakeswap-libs/sdk'\n// import { Button, CardBody, AddIcon, Text as UIKitText } from '@pancakeswap-libs/uikit'\n// import { RouteComponentProps } from 'react-router-dom'\n// import { LightCard } from 'components/Card'\n// import { AutoColumn, ColumnCenter } from 'components/Column'\n// import TransactionConfirmationModal, { ConfirmationModalContent } from 'components/TransactionConfirmationModal'\n// import CardNav from 'components/CardNav'\n// import CurrencyInputPanel from 'components/CurrencyInputPanel'\n// import DoubleCurrencyLogo from 'components/DoubleLogo'\n// import { AddRemoveTabs } from 'components/NavigationTabs'\n// import { MinimalPositionCard } from 'components/PositionCard'\n// import Row, { RowBetween, RowFlat } from 'components/Row'\n// import { PairState } from 'data/Reserves'\n// import { useActiveWeb3React } from 'hooks'\n// import { useCurrency } from 'hooks/Tokens'\n// import { ApprovalState, useApproveCallback } from 'hooks/useApproveCallback'\n// import { Field } from 'state/mint/actions'\n// import { useDerivedMintInfo, useMintActionHandlers, useMintState } from 'state/mint/hooks'\n// import { useTransactionAdder } from 'state/transactions/hooks'\n// import { useIsExpertMode, useUserDeadline, useUserSlippageTolerance } from 'state/user/hooks'\n// import { calculateGasMargin, calculateSlippageAmount, getRouterContract } from 'utils'\n// import { maxAmountSpend } from 'utils/maxAmountSpend'\n// import { wrappedCurrency } from 'utils/wrappedCurrency'\n// import { currencyId } from 'utils/currencyId'\n// import Pane from 'components/Pane'\n// import Container from 'components/Container'\n// import ConnectWalletButton from 'components/ConnectWalletButton'\n// import useI18n from 'hooks/useI18n'\n// import AppBody from '../AppBody'\n// import { Dots, Wrapper } from '../Pool/styleds'\n// import { ConfirmAddModalBottom } from './ConfirmAddModalBottom'\n// import { PoolPriceBar } from './PoolPriceBar'\n// import { ROUTER_ADDRESS } from '../../constants'\n// export default function AddLiquidity({\n//   match: {\n//     params: { currencyIdA, currencyIdB },\n//   },\n//   history,\n// }: RouteComponentProps<{ currencyIdA?: string; currencyIdB?: string }>) {\n//   const { account, chainId, library } = useActiveWeb3React()\n//   const currencyA = useCurrency(currencyIdA)\n//   const currencyB = useCurrency(currencyIdB)\n//   const TranslateString = useI18n()\n//   const oneCurrencyIsWBNB = Boolean(\n//     chainId &&\n//       ((currencyA && currencyEquals(currencyA, WETH[chainId])) ||\n//         (currencyB && currencyEquals(currencyB, WETH[chainId])))\n//   )\n//   const expertMode = useIsExpertMode()\n//   // mint state\n//   const { independentField, typedValue, otherTypedValue } = useMintState()\n//   const {\n//     dependentField,\n//     currencies,\n//     pair,\n//     pairState,\n//     currencyBalances,\n//     parsedAmounts,\n//     price,\n//     noLiquidity,\n//     liquidityMinted,\n//     poolTokenPercentage,\n//     error,\n//   } = useDerivedMintInfo(currencyA ?? undefined, currencyB ?? undefined)\n//   const { onFieldAInput, onFieldBInput } = useMintActionHandlers(noLiquidity)\n//   const isValid = !error\n//   // modal and loading\n//   const [showConfirm, setShowConfirm] = useState<boolean>(false)\n//   const [attemptingTxn, setAttemptingTxn] = useState<boolean>(false) // clicked confirm\n//   // txn values\n//   const [deadline] = useUserDeadline() // custom from users settings\n//   const [allowedSlippage] = useUserSlippageTolerance() // custom from users\n//   const [txHash, setTxHash] = useState<string>('')\n//   // get formatted amounts\n//   const formattedAmounts = {\n//     [independentField]: typedValue,\n//     [dependentField]: noLiquidity ? otherTypedValue : parsedAmounts[dependentField]?.toSignificant(6) ?? '',\n//   }\n//   // get the max amounts user can add\n//   const maxAmounts: { [field in Field]?: TokenAmount } = [Field.CURRENCY_A, Field.CURRENCY_B].reduce(\n//     (accumulator, field) => {\n//       return {\n//         ...accumulator,\n//         [field]: maxAmountSpend(currencyBalances[field]),\n//       }\n//     },\n//     {}\n//   )\n//   const atMaxAmounts: { [field in Field]?: TokenAmount } = [Field.CURRENCY_A, Field.CURRENCY_B].reduce(\n//     (accumulator, field) => {\n//       return {\n//         ...accumulator,\n//         [field]: maxAmounts[field]?.equalTo(parsedAmounts[field] ?? '0'),\n//       }\n//     },\n//     {}\n//   )\n//   // check whether the user has approved the router on the tokens\n//   const [approvalA, approveACallback] = useApproveCallback(parsedAmounts[Field.CURRENCY_A], ROUTER_ADDRESS)\n//   const [approvalB, approveBCallback] = useApproveCallback(parsedAmounts[Field.CURRENCY_B], ROUTER_ADDRESS)\n//   const addTransaction = useTransactionAdder()\n//   async function onAdd() {\n//     if (!chainId || !library || !account) return\n//     const router = getRouterContract(chainId, library, account)\n//     const { [Field.CURRENCY_A]: parsedAmountA, [Field.CURRENCY_B]: parsedAmountB } = parsedAmounts\n//     if (!parsedAmountA || !parsedAmountB || !currencyA || !currencyB) {\n//       return\n//     }\n//     const amountsMin = {\n//       [Field.CURRENCY_A]: calculateSlippageAmount(parsedAmountA, noLiquidity ? 0 : allowedSlippage)[0],\n//       [Field.CURRENCY_B]: calculateSlippageAmount(parsedAmountB, noLiquidity ? 0 : allowedSlippage)[0],\n//     }\n//     const deadlineFromNow = Math.ceil(Date.now() / 1000) + deadline\n//     let estimate\n//     let method: (...args: any) => Promise<TransactionResponse>\n//     let args: Array<string | string[] | number>\n//     let value: BigNumber | null\n//     if (currencyA === ETHER || currencyB === ETHER) {\n//       const tokenBIsBNB = currencyB === ETHER\n//       estimate = router.estimateGas.addLiquidityETH\n//       method = router.addLiquidityETH\n//       args = [\n//         wrappedCurrency(tokenBIsBNB ? currencyA : currencyB, chainId)?.address ?? '', // token\n//         (tokenBIsBNB ? parsedAmountA : parsedAmountB).raw.toString(), // token desired\n//         amountsMin[tokenBIsBNB ? Field.CURRENCY_A : Field.CURRENCY_B].toString(), // token min\n//         amountsMin[tokenBIsBNB ? Field.CURRENCY_B : Field.CURRENCY_A].toString(), // eth min\n//         account,\n//         deadlineFromNow,\n//       ]\n//       value = BigNumber.from((tokenBIsBNB ? parsedAmountB : parsedAmountA).raw.toString())\n//     } else {\n//       estimate = router.estimateGas.addLiquidity\n//       method = router.addLiquidity\n//       args = [\n//         wrappedCurrency(currencyA, chainId)?.address ?? '',\n//         wrappedCurrency(currencyB, chainId)?.address ?? '',\n//         parsedAmountA.raw.toString(),\n//         parsedAmountB.raw.toString(),\n//         amountsMin[Field.CURRENCY_A].toString(),\n//         amountsMin[Field.CURRENCY_B].toString(),\n//         account,\n//         deadlineFromNow,\n//       ]\n//       value = null\n//     }\n//     setAttemptingTxn(true)\n//     // const aa = await estimate(...args, value ? { value } : {})\n//     await estimate(...args, value ? { value } : {})\n//       .then((estimatedGasLimit) =>\n//         method(...args, {\n//           ...(value ? { value } : {}),\n//           gasLimit: calculateGasMargin(estimatedGasLimit),\n//         }).then((response) => {\n//           setAttemptingTxn(false)\n//           addTransaction(response, {\n//             summary: `Add ${parsedAmounts[Field.CURRENCY_A]?.toSignificant(3)} ${\n//               currencies[Field.CURRENCY_A]?.symbol\n//             } and ${parsedAmounts[Field.CURRENCY_B]?.toSignificant(3)} ${currencies[Field.CURRENCY_B]?.symbol}`,\n//           })\n//           setTxHash(response.hash)\n//         })\n//       )\n//       .catch((e) => {\n//         setAttemptingTxn(false)\n//         // we only care if the error is something _other_ than the user rejected the tx\n//         if (e?.code !== 4001) {\n//           console.error(e)\n//         }\n//       })\n//   }\n//   const modalHeader = () => {\n//     return noLiquidity ? (\n//       <AutoColumn gap=\"20px\">\n//         <LightCard mt=\"20px\" borderRadius=\"20px\">\n//           <RowFlat>\n//             <UIKitText fontSize=\"48px\" mr=\"8px\">\n//               {`${currencies[Field.CURRENCY_A]?.symbol}/${currencies[Field.CURRENCY_B]?.symbol}`}\n//             </UIKitText>\n//             <DoubleCurrencyLogo\n//               currency0={currencies[Field.CURRENCY_A]}\n//               currency1={currencies[Field.CURRENCY_B]}\n//               size={30}\n//             />\n//           </RowFlat>\n//         </LightCard>\n//       </AutoColumn>\n//     ) : (\n//       <AutoColumn gap=\"20px\">\n//         <RowFlat style={{ marginTop: '20px' }}>\n//           <UIKitText fontSize=\"48px\" mr=\"8px\">\n//             {liquidityMinted?.toSignificant(6)}\n//           </UIKitText>\n//           <DoubleCurrencyLogo\n//             currency0={currencies[Field.CURRENCY_A]}\n//             currency1={currencies[Field.CURRENCY_B]}\n//             size={30}\n//           />\n//         </RowFlat>\n//         <Row>\n//           <UIKitText fontSize=\"24px\">\n//             {`${currencies[Field.CURRENCY_A]?.symbol}/${currencies[Field.CURRENCY_B]?.symbol} Pool Tokens`}\n//           </UIKitText>\n//         </Row>\n//         <UIKitText small textAlign=\"left\" padding=\"8px 0 0 0 \" style={{ fontStyle: 'italic' }}>\n//           {`Output is estimated. If the price changes by more than ${\n//             allowedSlippage / 100\n//           }% your transaction will revert.`}\n//         </UIKitText>\n//       </AutoColumn>\n//     )\n//   }\n//   const modalBottom = () => {\n//     return (\n//       <ConfirmAddModalBottom\n//         price={price}\n//         currencies={currencies}\n//         parsedAmounts={parsedAmounts}\n//         noLiquidity={noLiquidity}\n//         onAdd={onAdd}\n//         poolTokenPercentage={poolTokenPercentage}\n//       />\n//     )\n//   }\n//   const pendingText = `Supplying ${parsedAmounts[Field.CURRENCY_A]?.toSignificant(6)} ${\n//     currencies[Field.CURRENCY_A]?.symbol\n//   } and ${parsedAmounts[Field.CURRENCY_B]?.toSignificant(6)} ${currencies[Field.CURRENCY_B]?.symbol}`\n//   const handleCurrencyASelect = useCallback(\n//     (currA: Currency) => {\n//       const newCurrencyIdA = currencyId(currA)\n//       if (newCurrencyIdA === currencyIdB) {\n//         history.push(`/add/${currencyIdB}/${currencyIdA}`)\n//       } else {\n//         history.push(`/add/${newCurrencyIdA}/${currencyIdB}`)\n//       }\n//     },\n//     [currencyIdB, history, currencyIdA]\n//   )\n//   const handleCurrencyBSelect = useCallback(\n//     (currB: Currency) => {\n//       const newCurrencyIdB = currencyId(currB)\n//       if (currencyIdA === newCurrencyIdB) {\n//         if (currencyIdB) {\n//           history.push(`/add/${currencyIdB}/${newCurrencyIdB}`)\n//         } else {\n//           history.push(`/add/${newCurrencyIdB}`)\n//         }\n//       } else {\n//         history.push(`/add/${currencyIdA || 'BNB'}/${newCurrencyIdB}`)\n//       }\n//     },\n//     [currencyIdA, history, currencyIdB]\n//   )\n//   const handleDismissConfirmation = useCallback(() => {\n//     setShowConfirm(false)\n//     // if there was a tx hash, we want to clear the input\n//     if (txHash) {\n//       onFieldAInput('')\n//     }\n//     setTxHash('')\n//   }, [onFieldAInput, txHash])\n//   return (\n//     <Container>\n//       <CardNav activeIndex={1} />\n//       <AppBody>\n//         <AddRemoveTabs adding />\n//         <Wrapper>\n//           <TransactionConfirmationModal\n//             isOpen={showConfirm}\n//             onDismiss={handleDismissConfirmation}\n//             attemptingTxn={attemptingTxn}\n//             hash={txHash}\n//             content={() => (\n//               <ConfirmationModalContent\n//                 title={\n//                   noLiquidity\n//                     ? TranslateString(1154, 'You are creating a pool')\n//                     : TranslateString(1156, 'You will receive')\n//                 }\n//                 onDismiss={handleDismissConfirmation}\n//                 topContent={modalHeader}\n//                 bottomContent={modalBottom}\n//               />\n//             )}\n//             pendingText={pendingText}\n//           />\n//           <CardBody>\n//             <AutoColumn gap=\"20px\">\n//               {noLiquidity && (\n//                 <ColumnCenter>\n//                   <Pane>\n//                     <AutoColumn gap=\"12px\">\n//                       <UIKitText>{TranslateString(1158, 'You are the first liquidity provider.')}</UIKitText>\n//                       <UIKitText>\n//                         {TranslateString(1160, 'The ratio of tokens you add will set the price of this pool.')}\n//                       </UIKitText>\n//                       <UIKitText>\n//                         {TranslateString(1162, 'Once you are happy with the rate click supply to review.')}\n//                       </UIKitText>\n//                     </AutoColumn>\n//                   </Pane>\n//                 </ColumnCenter>\n//               )}\n//               <CurrencyInputPanel\n//                 value={formattedAmounts[Field.CURRENCY_A]}\n//                 onUserInput={onFieldAInput}\n//                 onMax={() => {\n//                   onFieldAInput(maxAmounts[Field.CURRENCY_A]?.toExact() ?? '')\n//                 }}\n//                 onCurrencySelect={handleCurrencyASelect}\n//                 showMaxButton={!atMaxAmounts[Field.CURRENCY_A]}\n//                 currency={currencies[Field.CURRENCY_A]}\n//                 id=\"add-liquidity-input-tokena\"\n//                 showCommonBases={false}\n//               />\n//               <ColumnCenter>\n//                 <AddIcon color=\"textSubtle\" />\n//               </ColumnCenter>\n//               <CurrencyInputPanel\n//                 value={formattedAmounts[Field.CURRENCY_B]}\n//                 onUserInput={onFieldBInput}\n//                 onCurrencySelect={handleCurrencyBSelect}\n//                 onMax={() => {\n//                   onFieldBInput(maxAmounts[Field.CURRENCY_B]?.toExact() ?? '')\n//                 }}\n//                 showMaxButton={!atMaxAmounts[Field.CURRENCY_B]}\n//                 currency={currencies[Field.CURRENCY_B]}\n//                 id=\"add-liquidity-input-tokenb\"\n//                 showCommonBases={false}\n//               />\n//               {currencies[Field.CURRENCY_A] && currencies[Field.CURRENCY_B] && pairState !== PairState.INVALID && (\n//                 <div>\n//                   <UIKitText\n//                     style={{ textTransform: 'uppercase', fontWeight: 600 }}\n//                     color=\"textSubtle\"\n//                     fontSize=\"12px\"\n//                     mb=\"2px\"\n//                   >\n//                     {noLiquidity\n//                       ? TranslateString(1164, 'Initial prices and pool share')\n//                       : TranslateString(1166, 'Prices and pool share')}\n//                   </UIKitText>\n//                   <Pane>\n//                     <PoolPriceBar\n//                       currencies={currencies}\n//                       poolTokenPercentage={poolTokenPercentage}\n//                       noLiquidity={noLiquidity}\n//                       price={price}\n//                     />\n//                   </Pane>\n//                 </div>\n//               )}\n//               {!account ? (\n//                 <ConnectWalletButton width=\"100%\" />\n//               ) : (\n//                 <AutoColumn gap=\"md\">\n//                   {(approvalA === ApprovalState.NOT_APPROVED ||\n//                     approvalA === ApprovalState.PENDING ||\n//                     approvalB === ApprovalState.NOT_APPROVED ||\n//                     approvalB === ApprovalState.PENDING) &&\n//                     isValid && (\n//                       <RowBetween>\n//                         {approvalA !== ApprovalState.APPROVED && (\n//                           <Button\n//                             onClick={approveACallback}\n//                             disabled={approvalA === ApprovalState.PENDING}\n//                             style={{ width: approvalB !== ApprovalState.APPROVED ? '48%' : '100%' }}\n//                           >\n//                             {approvalA === ApprovalState.PENDING ? (\n//                               <Dots>Approving {currencies[Field.CURRENCY_A]?.symbol}</Dots>\n//                             ) : (\n//                               `Approve ${currencies[Field.CURRENCY_A]?.symbol}`\n//                             )}\n//                           </Button>\n//                         )}\n//                         {approvalB !== ApprovalState.APPROVED && (\n//                           <Button\n//                             onClick={approveBCallback}\n//                             disabled={approvalB === ApprovalState.PENDING}\n//                             style={{ width: approvalA !== ApprovalState.APPROVED ? '48%' : '100%' }}\n//                           >\n//                             {approvalB === ApprovalState.PENDING ? (\n//                               <Dots>Approving {currencies[Field.CURRENCY_B]?.symbol}</Dots>\n//                             ) : (\n//                               `Approve ${currencies[Field.CURRENCY_B]?.symbol}`\n//                             )}\n//                           </Button>\n//                         )}\n//                       </RowBetween>\n//                     )}\n//                   <Button\n//                     onClick={() => {\n//                       if (expertMode) {\n//                         onAdd()\n//                       } else {\n//                         setShowConfirm(true)\n//                       }\n//                     }}\n//                     disabled\n//                     variant={\n//                       !isValid && !!parsedAmounts[Field.CURRENCY_A] && !!parsedAmounts[Field.CURRENCY_B]\n//                         ? 'danger'\n//                         : 'primary'\n//                     }\n//                     width=\"100%\"\n//                   >\n//                     {error ?? \"You can't add liquidity on V1\"}\n//                   </Button>\n//                 </AutoColumn>\n//               )}\n//             </AutoColumn>\n//           </CardBody>\n//         </Wrapper>\n//       </AppBody>\n//       {pair && !noLiquidity && pairState !== PairState.INVALID ? (\n//         <AutoColumn style={{ minWidth: '20rem', marginTop: '1rem' }}>\n//           <MinimalPositionCard showUnwrapped={oneCurrencyIsWBNB} pair={pair} />\n//         </AutoColumn>\n//       ) : null}\n//     </Container>\n//   )\n// }","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/src/pages/AddLiquidity/index.tsx"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import React, { useCallback, useState } from 'react'\n// import { BigNumber } from '@ethersproject/bignumber'\n// import { TransactionResponse } from '@ethersproject/providers'\n// import { Currency, currencyEquals, ETHER, TokenAmount, WETH } from '@pancakeswap-libs/sdk'\n// import { Button, CardBody, AddIcon, Text as UIKitText } from '@pancakeswap-libs/uikit'\n// import { RouteComponentProps } from 'react-router-dom'\n// import { LightCard } from 'components/Card'\n// import { AutoColumn, ColumnCenter } from 'components/Column'\n// import TransactionConfirmationModal, { ConfirmationModalContent } from 'components/TransactionConfirmationModal'\n// import CardNav from 'components/CardNav'\n// import CurrencyInputPanel from 'components/CurrencyInputPanel'\n// import DoubleCurrencyLogo from 'components/DoubleLogo'\n// import { AddRemoveTabs } from 'components/NavigationTabs'\n// import { MinimalPositionCard } from 'components/PositionCard'\n// import Row, { RowBetween, RowFlat } from 'components/Row'\n\n// import { PairState } from 'data/Reserves'\n// import { useActiveWeb3React } from 'hooks'\n// import { useCurrency } from 'hooks/Tokens'\n// import { ApprovalState, useApproveCallback } from 'hooks/useApproveCallback'\n// import { Field } from 'state/mint/actions'\n// import { useDerivedMintInfo, useMintActionHandlers, useMintState } from 'state/mint/hooks'\n\n// import { useTransactionAdder } from 'state/transactions/hooks'\n// import { useIsExpertMode, useUserDeadline, useUserSlippageTolerance } from 'state/user/hooks'\n// import { calculateGasMargin, calculateSlippageAmount, getRouterContract } from 'utils'\n// import { maxAmountSpend } from 'utils/maxAmountSpend'\n// import { wrappedCurrency } from 'utils/wrappedCurrency'\n// import { currencyId } from 'utils/currencyId'\n// import Pane from 'components/Pane'\n// import Container from 'components/Container'\n// import ConnectWalletButton from 'components/ConnectWalletButton'\n// import useI18n from 'hooks/useI18n'\n// import AppBody from '../AppBody'\n// import { Dots, Wrapper } from '../Pool/styleds'\n// import { ConfirmAddModalBottom } from './ConfirmAddModalBottom'\n// import { PoolPriceBar } from './PoolPriceBar'\n// import { ROUTER_ADDRESS } from '../../constants'\n\n// export default function AddLiquidity({\n//   match: {\n//     params: { currencyIdA, currencyIdB },\n//   },\n//   history,\n// }: RouteComponentProps<{ currencyIdA?: string; currencyIdB?: string }>) {\n//   const { account, chainId, library } = useActiveWeb3React()\n//   const currencyA = useCurrency(currencyIdA)\n//   const currencyB = useCurrency(currencyIdB)\n//   const TranslateString = useI18n()\n\n//   const oneCurrencyIsWBNB = Boolean(\n//     chainId &&\n//       ((currencyA && currencyEquals(currencyA, WETH[chainId])) ||\n//         (currencyB && currencyEquals(currencyB, WETH[chainId])))\n//   )\n//   const expertMode = useIsExpertMode()\n\n//   // mint state\n//   const { independentField, typedValue, otherTypedValue } = useMintState()\n//   const {\n//     dependentField,\n//     currencies,\n//     pair,\n//     pairState,\n//     currencyBalances,\n//     parsedAmounts,\n//     price,\n//     noLiquidity,\n//     liquidityMinted,\n//     poolTokenPercentage,\n//     error,\n//   } = useDerivedMintInfo(currencyA ?? undefined, currencyB ?? undefined)\n//   const { onFieldAInput, onFieldBInput } = useMintActionHandlers(noLiquidity)\n\n//   const isValid = !error\n\n//   // modal and loading\n//   const [showConfirm, setShowConfirm] = useState<boolean>(false)\n//   const [attemptingTxn, setAttemptingTxn] = useState<boolean>(false) // clicked confirm\n\n//   // txn values\n//   const [deadline] = useUserDeadline() // custom from users settings\n//   const [allowedSlippage] = useUserSlippageTolerance() // custom from users\n//   const [txHash, setTxHash] = useState<string>('')\n\n//   // get formatted amounts\n//   const formattedAmounts = {\n//     [independentField]: typedValue,\n//     [dependentField]: noLiquidity ? otherTypedValue : parsedAmounts[dependentField]?.toSignificant(6) ?? '',\n//   }\n\n//   // get the max amounts user can add\n//   const maxAmounts: { [field in Field]?: TokenAmount } = [Field.CURRENCY_A, Field.CURRENCY_B].reduce(\n//     (accumulator, field) => {\n//       return {\n//         ...accumulator,\n//         [field]: maxAmountSpend(currencyBalances[field]),\n//       }\n//     },\n//     {}\n//   )\n\n//   const atMaxAmounts: { [field in Field]?: TokenAmount } = [Field.CURRENCY_A, Field.CURRENCY_B].reduce(\n//     (accumulator, field) => {\n//       return {\n//         ...accumulator,\n//         [field]: maxAmounts[field]?.equalTo(parsedAmounts[field] ?? '0'),\n//       }\n//     },\n//     {}\n//   )\n\n//   // check whether the user has approved the router on the tokens\n//   const [approvalA, approveACallback] = useApproveCallback(parsedAmounts[Field.CURRENCY_A], ROUTER_ADDRESS)\n//   const [approvalB, approveBCallback] = useApproveCallback(parsedAmounts[Field.CURRENCY_B], ROUTER_ADDRESS)\n\n//   const addTransaction = useTransactionAdder()\n\n//   async function onAdd() {\n//     if (!chainId || !library || !account) return\n//     const router = getRouterContract(chainId, library, account)\n\n//     const { [Field.CURRENCY_A]: parsedAmountA, [Field.CURRENCY_B]: parsedAmountB } = parsedAmounts\n//     if (!parsedAmountA || !parsedAmountB || !currencyA || !currencyB) {\n//       return\n//     }\n\n//     const amountsMin = {\n//       [Field.CURRENCY_A]: calculateSlippageAmount(parsedAmountA, noLiquidity ? 0 : allowedSlippage)[0],\n//       [Field.CURRENCY_B]: calculateSlippageAmount(parsedAmountB, noLiquidity ? 0 : allowedSlippage)[0],\n//     }\n\n//     const deadlineFromNow = Math.ceil(Date.now() / 1000) + deadline\n\n//     let estimate\n//     let method: (...args: any) => Promise<TransactionResponse>\n//     let args: Array<string | string[] | number>\n//     let value: BigNumber | null\n//     if (currencyA === ETHER || currencyB === ETHER) {\n//       const tokenBIsBNB = currencyB === ETHER\n//       estimate = router.estimateGas.addLiquidityETH\n//       method = router.addLiquidityETH\n//       args = [\n//         wrappedCurrency(tokenBIsBNB ? currencyA : currencyB, chainId)?.address ?? '', // token\n//         (tokenBIsBNB ? parsedAmountA : parsedAmountB).raw.toString(), // token desired\n//         amountsMin[tokenBIsBNB ? Field.CURRENCY_A : Field.CURRENCY_B].toString(), // token min\n//         amountsMin[tokenBIsBNB ? Field.CURRENCY_B : Field.CURRENCY_A].toString(), // eth min\n//         account,\n//         deadlineFromNow,\n//       ]\n//       value = BigNumber.from((tokenBIsBNB ? parsedAmountB : parsedAmountA).raw.toString())\n//     } else {\n//       estimate = router.estimateGas.addLiquidity\n//       method = router.addLiquidity\n//       args = [\n//         wrappedCurrency(currencyA, chainId)?.address ?? '',\n//         wrappedCurrency(currencyB, chainId)?.address ?? '',\n//         parsedAmountA.raw.toString(),\n//         parsedAmountB.raw.toString(),\n//         amountsMin[Field.CURRENCY_A].toString(),\n//         amountsMin[Field.CURRENCY_B].toString(),\n//         account,\n//         deadlineFromNow,\n//       ]\n//       value = null\n//     }\n\n//     setAttemptingTxn(true)\n//     // const aa = await estimate(...args, value ? { value } : {})\n//     await estimate(...args, value ? { value } : {})\n//       .then((estimatedGasLimit) =>\n//         method(...args, {\n//           ...(value ? { value } : {}),\n//           gasLimit: calculateGasMargin(estimatedGasLimit),\n//         }).then((response) => {\n//           setAttemptingTxn(false)\n\n//           addTransaction(response, {\n//             summary: `Add ${parsedAmounts[Field.CURRENCY_A]?.toSignificant(3)} ${\n//               currencies[Field.CURRENCY_A]?.symbol\n//             } and ${parsedAmounts[Field.CURRENCY_B]?.toSignificant(3)} ${currencies[Field.CURRENCY_B]?.symbol}`,\n//           })\n\n//           setTxHash(response.hash)\n//         })\n//       )\n//       .catch((e) => {\n//         setAttemptingTxn(false)\n//         // we only care if the error is something _other_ than the user rejected the tx\n//         if (e?.code !== 4001) {\n//           console.error(e)\n//         }\n//       })\n//   }\n\n//   const modalHeader = () => {\n//     return noLiquidity ? (\n//       <AutoColumn gap=\"20px\">\n//         <LightCard mt=\"20px\" borderRadius=\"20px\">\n//           <RowFlat>\n//             <UIKitText fontSize=\"48px\" mr=\"8px\">\n//               {`${currencies[Field.CURRENCY_A]?.symbol}/${currencies[Field.CURRENCY_B]?.symbol}`}\n//             </UIKitText>\n//             <DoubleCurrencyLogo\n//               currency0={currencies[Field.CURRENCY_A]}\n//               currency1={currencies[Field.CURRENCY_B]}\n//               size={30}\n//             />\n//           </RowFlat>\n//         </LightCard>\n//       </AutoColumn>\n//     ) : (\n//       <AutoColumn gap=\"20px\">\n//         <RowFlat style={{ marginTop: '20px' }}>\n//           <UIKitText fontSize=\"48px\" mr=\"8px\">\n//             {liquidityMinted?.toSignificant(6)}\n//           </UIKitText>\n//           <DoubleCurrencyLogo\n//             currency0={currencies[Field.CURRENCY_A]}\n//             currency1={currencies[Field.CURRENCY_B]}\n//             size={30}\n//           />\n//         </RowFlat>\n//         <Row>\n//           <UIKitText fontSize=\"24px\">\n//             {`${currencies[Field.CURRENCY_A]?.symbol}/${currencies[Field.CURRENCY_B]?.symbol} Pool Tokens`}\n//           </UIKitText>\n//         </Row>\n//         <UIKitText small textAlign=\"left\" padding=\"8px 0 0 0 \" style={{ fontStyle: 'italic' }}>\n//           {`Output is estimated. If the price changes by more than ${\n//             allowedSlippage / 100\n//           }% your transaction will revert.`}\n//         </UIKitText>\n//       </AutoColumn>\n//     )\n//   }\n\n//   const modalBottom = () => {\n//     return (\n//       <ConfirmAddModalBottom\n//         price={price}\n//         currencies={currencies}\n//         parsedAmounts={parsedAmounts}\n//         noLiquidity={noLiquidity}\n//         onAdd={onAdd}\n//         poolTokenPercentage={poolTokenPercentage}\n//       />\n//     )\n//   }\n\n//   const pendingText = `Supplying ${parsedAmounts[Field.CURRENCY_A]?.toSignificant(6)} ${\n//     currencies[Field.CURRENCY_A]?.symbol\n//   } and ${parsedAmounts[Field.CURRENCY_B]?.toSignificant(6)} ${currencies[Field.CURRENCY_B]?.symbol}`\n\n//   const handleCurrencyASelect = useCallback(\n//     (currA: Currency) => {\n//       const newCurrencyIdA = currencyId(currA)\n//       if (newCurrencyIdA === currencyIdB) {\n//         history.push(`/add/${currencyIdB}/${currencyIdA}`)\n//       } else {\n//         history.push(`/add/${newCurrencyIdA}/${currencyIdB}`)\n//       }\n//     },\n//     [currencyIdB, history, currencyIdA]\n//   )\n//   const handleCurrencyBSelect = useCallback(\n//     (currB: Currency) => {\n//       const newCurrencyIdB = currencyId(currB)\n//       if (currencyIdA === newCurrencyIdB) {\n//         if (currencyIdB) {\n//           history.push(`/add/${currencyIdB}/${newCurrencyIdB}`)\n//         } else {\n//           history.push(`/add/${newCurrencyIdB}`)\n//         }\n//       } else {\n//         history.push(`/add/${currencyIdA || 'BNB'}/${newCurrencyIdB}`)\n//       }\n//     },\n//     [currencyIdA, history, currencyIdB]\n//   )\n\n//   const handleDismissConfirmation = useCallback(() => {\n//     setShowConfirm(false)\n//     // if there was a tx hash, we want to clear the input\n//     if (txHash) {\n//       onFieldAInput('')\n//     }\n//     setTxHash('')\n//   }, [onFieldAInput, txHash])\n\n//   return (\n//     <Container>\n//       <CardNav activeIndex={1} />\n//       <AppBody>\n//         <AddRemoveTabs adding />\n//         <Wrapper>\n//           <TransactionConfirmationModal\n//             isOpen={showConfirm}\n//             onDismiss={handleDismissConfirmation}\n//             attemptingTxn={attemptingTxn}\n//             hash={txHash}\n//             content={() => (\n//               <ConfirmationModalContent\n//                 title={\n//                   noLiquidity\n//                     ? TranslateString(1154, 'You are creating a pool')\n//                     : TranslateString(1156, 'You will receive')\n//                 }\n//                 onDismiss={handleDismissConfirmation}\n//                 topContent={modalHeader}\n//                 bottomContent={modalBottom}\n//               />\n//             )}\n//             pendingText={pendingText}\n//           />\n//           <CardBody>\n//             <AutoColumn gap=\"20px\">\n//               {noLiquidity && (\n//                 <ColumnCenter>\n//                   <Pane>\n//                     <AutoColumn gap=\"12px\">\n//                       <UIKitText>{TranslateString(1158, 'You are the first liquidity provider.')}</UIKitText>\n//                       <UIKitText>\n//                         {TranslateString(1160, 'The ratio of tokens you add will set the price of this pool.')}\n//                       </UIKitText>\n//                       <UIKitText>\n//                         {TranslateString(1162, 'Once you are happy with the rate click supply to review.')}\n//                       </UIKitText>\n//                     </AutoColumn>\n//                   </Pane>\n//                 </ColumnCenter>\n//               )}\n//               <CurrencyInputPanel\n//                 value={formattedAmounts[Field.CURRENCY_A]}\n//                 onUserInput={onFieldAInput}\n//                 onMax={() => {\n//                   onFieldAInput(maxAmounts[Field.CURRENCY_A]?.toExact() ?? '')\n//                 }}\n//                 onCurrencySelect={handleCurrencyASelect}\n//                 showMaxButton={!atMaxAmounts[Field.CURRENCY_A]}\n//                 currency={currencies[Field.CURRENCY_A]}\n//                 id=\"add-liquidity-input-tokena\"\n//                 showCommonBases={false}\n//               />\n//               <ColumnCenter>\n//                 <AddIcon color=\"textSubtle\" />\n//               </ColumnCenter>\n//               <CurrencyInputPanel\n//                 value={formattedAmounts[Field.CURRENCY_B]}\n//                 onUserInput={onFieldBInput}\n//                 onCurrencySelect={handleCurrencyBSelect}\n//                 onMax={() => {\n//                   onFieldBInput(maxAmounts[Field.CURRENCY_B]?.toExact() ?? '')\n//                 }}\n//                 showMaxButton={!atMaxAmounts[Field.CURRENCY_B]}\n//                 currency={currencies[Field.CURRENCY_B]}\n//                 id=\"add-liquidity-input-tokenb\"\n//                 showCommonBases={false}\n//               />\n//               {currencies[Field.CURRENCY_A] && currencies[Field.CURRENCY_B] && pairState !== PairState.INVALID && (\n//                 <div>\n//                   <UIKitText\n//                     style={{ textTransform: 'uppercase', fontWeight: 600 }}\n//                     color=\"textSubtle\"\n//                     fontSize=\"12px\"\n//                     mb=\"2px\"\n//                   >\n//                     {noLiquidity\n//                       ? TranslateString(1164, 'Initial prices and pool share')\n//                       : TranslateString(1166, 'Prices and pool share')}\n//                   </UIKitText>\n//                   <Pane>\n//                     <PoolPriceBar\n//                       currencies={currencies}\n//                       poolTokenPercentage={poolTokenPercentage}\n//                       noLiquidity={noLiquidity}\n//                       price={price}\n//                     />\n//                   </Pane>\n//                 </div>\n//               )}\n\n//               {!account ? (\n//                 <ConnectWalletButton width=\"100%\" />\n//               ) : (\n//                 <AutoColumn gap=\"md\">\n//                   {(approvalA === ApprovalState.NOT_APPROVED ||\n//                     approvalA === ApprovalState.PENDING ||\n//                     approvalB === ApprovalState.NOT_APPROVED ||\n//                     approvalB === ApprovalState.PENDING) &&\n//                     isValid && (\n//                       <RowBetween>\n//                         {approvalA !== ApprovalState.APPROVED && (\n//                           <Button\n//                             onClick={approveACallback}\n//                             disabled={approvalA === ApprovalState.PENDING}\n//                             style={{ width: approvalB !== ApprovalState.APPROVED ? '48%' : '100%' }}\n//                           >\n//                             {approvalA === ApprovalState.PENDING ? (\n//                               <Dots>Approving {currencies[Field.CURRENCY_A]?.symbol}</Dots>\n//                             ) : (\n//                               `Approve ${currencies[Field.CURRENCY_A]?.symbol}`\n//                             )}\n//                           </Button>\n//                         )}\n//                         {approvalB !== ApprovalState.APPROVED && (\n//                           <Button\n//                             onClick={approveBCallback}\n//                             disabled={approvalB === ApprovalState.PENDING}\n//                             style={{ width: approvalA !== ApprovalState.APPROVED ? '48%' : '100%' }}\n//                           >\n//                             {approvalB === ApprovalState.PENDING ? (\n//                               <Dots>Approving {currencies[Field.CURRENCY_B]?.symbol}</Dots>\n//                             ) : (\n//                               `Approve ${currencies[Field.CURRENCY_B]?.symbol}`\n//                             )}\n//                           </Button>\n//                         )}\n//                       </RowBetween>\n//                     )}\n//                   <Button\n//                     onClick={() => {\n//                       if (expertMode) {\n//                         onAdd()\n//                       } else {\n//                         setShowConfirm(true)\n//                       }\n//                     }}\n//                     disabled\n//                     variant={\n//                       !isValid && !!parsedAmounts[Field.CURRENCY_A] && !!parsedAmounts[Field.CURRENCY_B]\n//                         ? 'danger'\n//                         : 'primary'\n//                     }\n//                     width=\"100%\"\n//                   >\n//                     {error ?? \"You can't add liquidity on V1\"}\n//                   </Button>\n//                 </AutoColumn>\n//               )}\n//             </AutoColumn>\n//           </CardBody>\n//         </Wrapper>\n//       </AppBody>\n//       {pair && !noLiquidity && pairState !== PairState.INVALID ? (\n//         <AutoColumn style={{ minWidth: '20rem', marginTop: '1rem' }}>\n//           <MinimalPositionCard showUnwrapped={oneCurrencyIsWBNB} pair={pair} />\n//         </AutoColumn>\n//       ) : null}\n//     </Container>\n//   )\n// }\n"]},"metadata":{},"sourceType":"module"}