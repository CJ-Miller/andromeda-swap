{"ast":null,"code":"import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftyp\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    return !_isLikely['3gp'](bytes) && !_isLikely.mov(bytes) && (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    }));\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/containers.js"],"names":["toUint8","bytesMatch","findBox","findEbml","EBML_TAGS","getId3Offset","findH264Nal","findH265Nal","CONSTANTS","_isLikely","aac","bytes","offset","mask","mp3","webm","docType","EBML","DocType","mkv","matroska","mp4","mov","fmp4","gp","ac3","ts","length","i","flac","ogg","avi","riff","wav","h264","h265","isLikelyTypes","Object","keys","filter","t","concat","forEach","type","isLikelyFn","isLikely","detectContainerForBytes","isLikelyFmp4MediaSegment"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,UAAlB,QAAoC,mBAApC;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,mBAApC;AACA,SAASC,YAAT,QAA6B,kBAA7B;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,kBAAzC;AACA,IAAIC,SAAS,GAAG;AACd;AACA,UAAQR,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAFD;AAGd;AACA,cAAYA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAD,CAJL;AAKd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAND;AAOd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CARA;AASd;AACA;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,CAXA;AAYd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAbD;AAcd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAD,CAfA;AAgBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAjBA;AAkBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAD,CAnBA;AAoBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CArBA;AAsBd;AACA,UAAQA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,CAAD,CAvBD;AAwBd;AACA,SAAOA,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAD;AAzBA,CAAhB;AA2BA,IAAIS,SAAS,GAAG;AACdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaC,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQ,CAAC,IAAD,EAAO,IAAP,CAAR,EAAsB;AACrCC,MAAAA,MAAM,EAAEA,MAD6B;AAErCC,MAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAF+B,KAAtB,CAAjB;AAID,GAPa;AAQdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaH,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQ,CAAC,IAAD,EAAO,IAAP,CAAR,EAAsB;AACrCC,MAAAA,MAAM,EAAEA,MAD6B;AAErCC,MAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAF+B,KAAtB,CAAjB;AAID,GAda;AAedE,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcJ,KAAd,EAAqB;AACzB,QAAIK,OAAO,GAAGb,QAAQ,CAACQ,KAAD,EAAQ,CAACP,SAAS,CAACa,IAAX,EAAiBb,SAAS,CAACc,OAA3B,CAAR,CAAR,CAAqD,CAArD,CAAd,CADyB,CAC8C;;AAEvE,WAAOjB,UAAU,CAACe,OAAD,EAAUR,SAAS,CAACO,IAApB,CAAjB;AACD,GAnBa;AAoBdI,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaR,KAAb,EAAoB;AACvB,QAAIK,OAAO,GAAGb,QAAQ,CAACQ,KAAD,EAAQ,CAACP,SAAS,CAACa,IAAX,EAAiBb,SAAS,CAACc,OAA3B,CAAR,CAAR,CAAqD,CAArD,CAAd,CADuB,CACgD;;AAEvE,WAAOjB,UAAU,CAACe,OAAD,EAAUR,SAAS,CAACY,QAApB,CAAjB;AACD,GAxBa;AAyBdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaV,KAAb,EAAoB;AACvB,WAAO,CAACF,SAAS,CAAC,KAAD,CAAT,CAAiBE,KAAjB,CAAD,IAA4B,CAACF,SAAS,CAACa,GAAV,CAAcX,KAAd,CAA7B,KAAsDV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACa,GAAlB,EAAuB;AAC5FT,MAAAA,MAAM,EAAE;AADoF,KAAvB,CAAV,IAEvDX,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACe,IAAlB,EAAwB;AACtCX,MAAAA,MAAM,EAAE;AAD8B,KAAxB,CAFT,CAAP;AAKD,GA/Ba;AAgCdU,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAaX,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACc,GAAlB,EAAuB;AACtCV,MAAAA,MAAM,EAAE;AAD8B,KAAvB,CAAjB;AAGD,GApCa;AAqCd,SAAO,SAASY,EAAT,CAAYb,KAAZ,EAAmB;AACxB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAAC,KAAD,CAAjB,EAA0B;AACzCI,MAAAA,MAAM,EAAE;AADiC,KAA1B,CAAjB;AAGD,GAzCa;AA0Cda,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAad,KAAb,EAAoB;AACvB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACiB,GAAlB,EAAuB;AACtCb,MAAAA,MAAM,EAAEA;AAD8B,KAAvB,CAAjB;AAGD,GA/Ca;AAgDdc,EAAAA,EAAE,EAAE,SAASA,EAAT,CAAYf,KAAZ,EAAmB;AACrB,QAAIA,KAAK,CAACgB,MAAN,GAAe,GAAf,IAAsBhB,KAAK,CAACgB,MAAN,IAAgB,CAA1C,EAA6C;AAC3C,aAAOhB,KAAK,CAAC,CAAD,CAAL,KAAa,IAApB;AACD;;AAED,QAAIiB,CAAC,GAAG,CAAR,CALqB,CAKV;;AAEX,WAAOA,CAAC,GAAG,GAAJ,GAAUjB,KAAK,CAACgB,MAAhB,IAA0BC,CAAC,GAAG,GAArC,EAA0C;AACxC,UAAIjB,KAAK,CAACiB,CAAD,CAAL,KAAa,IAAb,IAAqBjB,KAAK,CAACiB,CAAC,GAAG,GAAL,CAAL,KAAmB,IAA5C,EAAkD;AAChD,eAAO,IAAP;AACD;;AAEDA,MAAAA,CAAC,IAAI,CAAL;AACD;;AAED,WAAO,KAAP;AACD,GAhEa;AAiEdC,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAclB,KAAd,EAAqB;AACzB,QAAIC,MAAM,GAAGP,YAAY,CAACM,KAAD,CAAzB;AACA,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACqB,IAAlB,EAAwB;AACvCjB,MAAAA,MAAM,EAAEA;AAD+B,KAAxB,CAAjB;AAGD,GAtEa;AAuEdkB,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAanB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACsB,GAAlB,CAAjB;AACD,GAzEa;AA0EdC,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAapB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACwB,IAAlB,CAAV,IAAqC/B,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACuB,GAAlB,EAAuB;AAC3EnB,MAAAA,MAAM,EAAE;AADmE,KAAvB,CAAtD;AAGD,GA9Ea;AA+EdqB,EAAAA,GAAG,EAAE,SAASA,GAAT,CAAatB,KAAb,EAAoB;AACvB,WAAOV,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACwB,IAAlB,CAAV,IAAqC/B,UAAU,CAACU,KAAD,EAAQH,SAAS,CAACyB,GAAlB,EAAuB;AAC3ErB,MAAAA,MAAM,EAAE;AADmE,KAAvB,CAAtD;AAGD,GAnFa;AAoFd,UAAQ,SAASsB,IAAT,CAAcvB,KAAd,EAAqB;AAC3B;AACA,WAAOL,WAAW,CAACK,KAAD,EAAQ,CAAR,EAAW,CAAX,CAAX,CAAyBgB,MAAhC;AACD,GAvFa;AAwFd,UAAQ,SAASQ,IAAT,CAAcxB,KAAd,EAAqB;AAC3B;AACA,WAAOJ,WAAW,CAACI,KAAD,EAAQ,CAAC,EAAD,EAAK,EAAL,CAAR,EAAkB,CAAlB,CAAX,CAAgCgB,MAAvC;AACD;AA3Fa,CAAhB,C,CA4FG;AACH;AACA;;AAEA,IAAIS,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAY7B,SAAZ,EAAuB;AAAvB,CACnB8B,MADmB,CACZ,UAAUC,CAAV,EAAa;AACnB,SAAOA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,MAApB,IAA8BA,CAAC,KAAK,MAA3C;AACD,CAHmB,EAGjB;AAHiB,CAInBC,MAJmB,CAIZ,CAAC,IAAD,EAAO,MAAP,EAAe,MAAf,CAJY,CAApB,C,CAIiC;;AAEjCL,aAAa,CAACM,OAAd,CAAsB,UAAUC,IAAV,EAAgB;AACpC,MAAIC,UAAU,GAAGnC,SAAS,CAACkC,IAAD,CAA1B;;AAEAlC,EAAAA,SAAS,CAACkC,IAAD,CAAT,GAAkB,UAAUhC,KAAV,EAAiB;AACjC,WAAOiC,UAAU,CAAC5C,OAAO,CAACW,KAAD,CAAR,CAAjB;AACD,GAFD;AAGD,CAND,E,CAMI;;AAEJ,OAAO,IAAIkC,QAAQ,GAAGpC,SAAf,C,CAA0B;AACjC;;AAEA,OAAO,IAAIqC,uBAAuB,GAAG,SAASA,uBAAT,CAAiCnC,KAAjC,EAAwC;AAC3EA,EAAAA,KAAK,GAAGX,OAAO,CAACW,KAAD,CAAf;;AAEA,OAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,aAAa,CAACT,MAAlC,EAA0CC,CAAC,EAA3C,EAA+C;AAC7C,QAAIe,IAAI,GAAGP,aAAa,CAACR,CAAD,CAAxB;;AAEA,QAAIiB,QAAQ,CAACF,IAAD,CAAR,CAAehC,KAAf,CAAJ,EAA2B;AACzB,aAAOgC,IAAP;AACD;AACF;;AAED,SAAO,EAAP;AACD,CAZM,C,CAYJ;;AAEH,OAAO,IAAII,wBAAwB,GAAG,SAASA,wBAAT,CAAkCpC,KAAlC,EAAyC;AAC7E,SAAOT,OAAO,CAACS,KAAD,EAAQ,CAAC,MAAD,CAAR,CAAP,CAAyBgB,MAAzB,GAAkC,CAAzC;AACD,CAFM","sourcesContent":["import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftyp\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    return !_isLikely['3gp'](bytes) && !_isLikely.mov(bytes) && (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    }));\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};"]},"metadata":{},"sourceType":"module"}