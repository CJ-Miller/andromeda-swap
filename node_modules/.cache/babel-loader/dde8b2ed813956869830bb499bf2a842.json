{"ast":null,"code":"import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};","map":{"version":3,"sources":["/Users/cj/Desktop/andromeda_swap_fork/pancake-swap-interface-v1/node_modules/@videojs/vhs-utils/es/mp4-helpers.js"],"names":["stringToBytes","toUint8","bytesMatch","bytesToString","toHexString","padStart","bytesToNumber","getAvcCodec","getHvcCodec","getAv1Codec","parseOpusHead","normalizePath","path","normalizePaths","paths","Array","isArray","map","p","DESCRIPTORS","parseDescriptors","bytes","results","i","length","tag","size","headerSize","byte","z","_DESCRIPTORS$z","id","parser","push","subarray","desc","flags","dependsOnEsId","ocrEsId","descriptors","url","len","oti","streamType","bufferSize","maxBitrate","avgBitrate","findBox","complete","type","end","data","apply","slice","findNamedBox","name","byteLength","parseSamples","entrySize","parseEntry","d","entries","entryCount","buildFrameTable","stbl","timescale","keySamples","chunkOffsets","timeToSamples","entry","sampleCount","sampleDelta","samplesToChunks","firstChunk","samplesPerChunk","sampleDescriptionIndex","stsz","sampleSizes","frames","chunkIndex","samplesInChunk","sampleToChunk","isThisOne","chunkOffset","_i","frameEnd","keyframe","indexOf","frame","start","k","_timeToSamples$k","lastTimestamp","timestamp","duration","addSampleDescription","track","codec","info","width","height","channels","bitDepth","sampleRate","avcC","esds","esDescriptor","decoderConfig","filter","_ref","toString","vpcC","profile","level","chromaSubsampling","videoFullRangeFlag","colourPrimaries","transferCharacteristics","matrixCoefficients","dOps","opus","codecDelay","toLowerCase","parseTracks","frameTable","traks","tracks","forEach","trak","mdia","hdlr","trakType","tkhd","view","DataView","buffer","byteOffset","tkhdVersion","getUint8","number","getUint32","mdhd","version","index","stsd","descriptionCount","offset","sampleDescriptor","parseMediaInfo","mvhd","timestampScale"],"mappings":"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","sourcesContent":["import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};"]},"metadata":{},"sourceType":"module"}